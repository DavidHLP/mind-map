---
markmap:
  colorFreezeLevel: 2
---

# 数组 vs 链表数组和链表在Java中的区别是什么

## 回答重点

### 在存储结构方面

- 数组
  - 基于连续的内存块
  - 大小固定
  - 需要重新分配内存来改变大小
  - 内存使用紧凑但容易浪费空间
- 链表
  - 基于节点的结构
  - 内存不需要连续
  - 可动态变化大小和插入删除节点
  - 内存不连续但可以动态扩展

### 在访问速度方面

- 数组
  - 支持 O(1) 时间随机访问
  - 可通过索引直接访问元素
  - 示例
    ```
    +----+----+----+----+----+----+
    | 10 | 20 | 30 | 40 | 50 | 60 |
    +----+----+----+----+----+----+
    ^
    | Index
    ```
- 链表
  - 访问特定元素需要 O(n) 时间
  - 节点在内存中不连续
  - 示例
    ```
    Head
     |
     v
    +----+--> +----+--> +----+--> NULL
    | 10 |    | 20 |    | 30 |
    +----+    +----+    +----+
      ^         ^         ^
      |         |         |
     Node      Node      Node
    ```

### 在操作方面

- 数组
  - 插入和删除需要移动数据
  - 时间复杂度 O(n)
- 链表
  - 可在 O(1) 时间插入和修改指定位置元素

### 在适用场景方面

- 数组
  - 适合快速随机访问且大小固定的场景
  - 例如缓存、表格等
- 链表
  - 适合频繁插入和删除操作且大小不确定的场景
  - 例如队列、栈、链表等

## 扩展知识

### 数组

- 内存连续，元素大小固定
- 随机访问通过 `下标 * 元素大小 + 内存基地址` 计算
- 删除中间元素需要搬迁，效率低

### 链表

- 内存不连续，通过指针相连
- 占用内存较多（额外存储指针）
- 访问元素必须顺序遍历，效率低 O(n)
- 删除元素高效，只需修改指针，但需要先找到元素

### CPU 缓存亲和性

- 空间局部性（spatial locality）：访问某个内存位置时，其附近位置也可能被访问
- 数组：连续内存，CPU 可预读，亲和性高
- 链表：内存不连续，CPU 预读困难，亲和性低
- 注意：不要与 CPU Affinity 混淆（线程绑定特定核心）

### 拓展用途

- 数组和链表都可实现栈、队列、双向队列
- 例如 `LinkedList` 可用作栈或队列

### 示例图

- 数组内存连续：
  ![数组](https://pic.code-nav.cn/mianshiya/question_picture/1783397053004488705/20220219202821_mianshiya.png)
- 链表节点通过指针连接：
  ![链表](https://pic.code-nav.cn/mianshiya/question_picture/1783397053004488705/20220219202832_mianshiya.png)
