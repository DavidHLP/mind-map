---
markmap:
  colorFreezeLevel: 2
---

# HashMap 与 ConcurrentHashMap 原理对比

## 一、HashMap 原理对比

### 1. HashMap 1.7

- 存储结构：数组 + 链表
- 链表长度优化：无
- 插入操作：直接在数组索引处插入链表头
- 扩容机制：整个数组翻倍，rehash
- 查询效率：链表 O(n)，平均 O(1)
- 线程安全：不安全

### 2. HashMap 1.8

- 存储结构：数组 + 链表/红黑树
- 链表长度优化：链表长度 > 8 且数组长度 > 64 时转红黑树
- 插入操作：同 1.7，链表转红黑树时使用平衡算法
- 扩容机制：同 1.7，扩容时重新计算 hash
- 查询效率：链表 O(n)，红黑树 O(log n)
- 线程安全：不安全

### 总结

- 最大区别：1.8 引入红黑树优化链表过长情况
- 线程安全：都不安全，多线程操作可能数据丢失或死循环

## 二、ConcurrentHashMap 原理对比

### 1. JDK 1.7

- 锁机制：分段锁（Segment），默认 16 个 Segment
- 存储结构：Segment 数组 + Segment 内部 HashEntry 链表
- 并发度：默认最多 16 个线程并发访问
- 插入操作：定位 Segment → synchronized 锁住 Segment → 插入链表
- 扩容机制：每个 Segment 单独扩容，rehash
- 查询操作：无锁，直接读取链表
- 特点：
  - 并发度有限
  - 锁粒度为 Segment
  - 内存浪费较多，结构复杂

### 2. JDK 1.8

- 锁机制：移除 Segment → 链表/红黑树头节点锁 + CAS
- 存储结构：数组 + 链表/红黑树（与 HashMap 1.8 相同）
- 并发度：更高，CAS 尝试插入，不同链表节点可以并发操作
- 插入操作：
  - 空位置 CAS 插入
  - 链表遍历 → 插入节点
  - 链表长度 > 8 → 转红黑树，锁头节点
- 扩容机制：数组扩容逐步迁移节点，支持线程帮助扩容
- 查询操作：无锁，直接读取节点；红黑树 O(log n)
- 特点：
  - 锁粒度细化，减少竞争
  - 插入大部分无需锁，性能高

## 三、对比总结

| 类                    | 线程安全 | 锁粒度              | 数据结构         | 并发度  | 扩容                     | key/value 支持               |
| --------------------- | -------- | ------------------- | ---------------- | ------- | ------------------------ | ---------------------------- |
| HashMap 1.7           | 否       | 无                  | 数组+链表        | 不支持  | 整体扩容                 | key/value 可 null            |
| HashMap 1.8           | 否       | 无                  | 数组+链表/红黑树 | 不支持  | 整体扩容                 | key/value 可 null            |
| ConcurrentHashMap 1.7 | 是       | Segment             | Segment+链表     | 默认 16 | Segment 单独扩容         | key 不可 null，value 可 null |
| ConcurrentHashMap 1.8 | 是       | 链表/树头节点 + CAS | 数组+链表/红黑树 | 高      | 节点迁移，可线程并发扩容 | key 不可 null，value 可 null |

## 四、核心变化总结

- HashMap 1.7 → 1.8
  - 链表过长转红黑树
  - 查询最坏时间 O(n) → O(log n)
- ConcurrentHashMap 1.7 → 1.8
  - 移除 Segment，锁粒度更细
  - CAS + 节点锁
  - 并发度大幅提升
  - 插入/扩容操作大部分无需锁
