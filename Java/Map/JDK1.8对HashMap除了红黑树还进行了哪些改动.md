---
markmap:
  colorFreezeLevel: 2
---

# JDK 1.8 对 HashMap 的改动 (除红黑树外)

## 回答重点

- **改进哈希函数计算**
  - 优化哈希函数，使用“扰动函数”让哈希值分布更均匀，减少冲突。
  - 确保哈希值的高低位都能参与到桶的选择中。
- **扩容机制优化**
  - 改进元素迁移机制，不再对每个元素重新计算索引。
  - 根据原数组长度的高位判断元素是留在原位还是迁移到新位置，提升扩容效率。
- **头插法变为尾插法**
  - **原因**: 1.7 的头插法在多线程扩容时，链表顺序会逆序，可能导致形成环形链表，造成死循环。
  - **优点**: 1.8 的尾插法在扩容后能保持链表元素的原有顺序，避免了多线程下的成环问题。

## 扩展知识

- **哈希函数的优化**
  - **JDK 1.7 实现** (4 次位移，4 次异或)
    ```java
    static int hash(int h) {
        h ^= (h >>> 20) ^ (h >>> 12);
        return h ^ (h >>> 7) ^ (h >>> 4);
    }
    ```
  - **JDK 1.8 实现** (1 次位移，1 次异或)
    ```java
    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
    ```
  - **优化点**
    - 1.8 将 key 的哈希码高 16 位与低 16 位异或，让 hash 值同时拥有高低位特性，分布更均匀。
    - 这是根据速度、实用性、哈希质量做的权衡。
    - ![JDK开发者注释](https://pic.code-nav.cn/mianshiya/question_picture/1783397053004488705/20220219203008.png)
- **扩容机制优化**
  - [参考: Java 中 HashMap 的扩容机制是怎样的？](https://www.mianshiya.com/bank/1788408712975282177/question/1780933294750199809#heading-2)
- **头插法 vs 尾插法**
  - **1.7 头插法**
    - **优点**: 插入时无需遍历链表，直接替换头结点。
    - **缺点**: 扩容时链表会逆序，多线程下可能导致死循环。
    - ![头插法导致成环](https://pic.code-nav.cn/mianshiya/question_picture/1783397053004488705/20220219203032_mianshiya.png)
  - **1.8 尾插法**
    - **优点**: 扩容后链表顺序不变，避免了多线程扩容成环。
  - **延伸思考: 改为尾插法后就不会死循环了吗?**
    - 仍然可能存在，问题可能转移到红黑树的并发操作上。
    - [参考文章](https://blog.csdn.net/qq_33330687/article/details/101479385)
