---
markmap:
  colorFreezeLevel: 2
---

# Java 中 HashMap 的扩容机制是怎样的

## 回答重点

- HashMap 的扩容基于 **负载因子（load factor）**
- 默认负载因子：0.75
  - 当存储元素数量 > 容量 × 0.75 时触发扩容
  - 例如：初始容量 16，阈值 = 12，存入第 13 个元素时扩容
- 扩容时容量 **翻倍**
  - 16 → 32 → 64 → ...
- 扩容过程：**rehashing**
  - 元素会重新计算位置并迁移到新数组中

## 扩展知识

### rehashing 细节

- JDK 1.7：逐个重新 hash 搬迁
- JDK 1.8：优化
  - 数组长度为 **2 的次方**
  - 扩容后只需看 hash 的高位
  - `(数组长度 - 1) & hash`
  - 判断关键：hash 值的某一位是否为 1
    - 若为 1 → 迁移到 `原位置 + 老数组长度`
    - 若为 0 → 保持在原位置
- **示例**：
  - 长度 16 → 二进制 010000
  - 长度 32 → 二进制 100000
  - `16-1=15 (001111)`
  - `32-1=31 (011111)`
- 扩容时链表整体搬运，但节点的新位置只有两种：原位置或原位置 + oldCap

- ![rehashing图示](https://pic.code-nav.cn/mianshiya/question_picture/1772087337535152129/MZ5ugCPs_10a4f9fc-9621-4d13-a0ce-c0f7dd012001_mianshiya.png)

**总结**：

- 扩容时并非简单复制，而是重新计算索引
- JDK 8 优化：通过位运算判断迁移位置，无需重新取模
  - 迁移计算开销降低

### 扩容的考虑

- 扩容需要遍历所有元素，性能开销大
- 频繁扩容 → 性能下降
- **优化策略**：预估容量，创建时指定大容量
  - 例如存储 100 万元素 → 直接设置初始容量 `1024 × 1024`
