---
markmap:
  colorFreezeLevel: 2
---

# JDK1.8 HashMap 红黑树改动

## 背景

- JDK1.8 之前
  - HashMap 使用链表解决哈希冲突
  - 当哈希冲突较多时
    - 链表元素增多
    - 查找/插入/删除复杂度退化为 O(n)

## 红黑树引入

- 改动
  - 引入红黑树
    - 条件：链表长度 > 8
  - 优势
    - 插入/删除/查找时间复杂度 O(logn)
    - 避免性能急剧下降

## 链表与红黑树转换机制

- 转换时机
  - 条件受链表长度和数组长度影响
  - 某个桶中的元素数量 >= 8 且数组长度 >= 64
    - 链表转换为红黑树
  - 如果数组长度 < 64
    - 选择扩容而非树化
  - 触发方法：bincount >= 7 时调用 `treeifyBin`
- 设计原因
  - 避免频繁树化
  - 减少内存占用
  - 小数组容量哈希冲突多，但扩容后冲突减少
  - 红黑树节点占用比链表大
  - 只有数组容量达到一定规模才允许树化
- 为什么不直接使用红黑树
  - 红黑树节点大约是普通节点的两倍
  - 默认阈值为 8
    - 与泊松分布有关
    - 在负载因子 0.75 下，冲突节点长度为 8 的概率极小（0.000000006）
  - 平衡时间和空间开销

## 红黑树退化为链表

- 条件：树节点数 <= 6
- 原因
  - 节点少时链表遍历仍快
  - 节约内存
  - 设置 6 而非 8 是为了缓冲，避免频繁树化/退化切换
    - 防止节点反复添加和删除导致链表/红黑树反复转换
