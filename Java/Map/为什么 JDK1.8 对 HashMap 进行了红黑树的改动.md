---
markmap:
  colorFreezeLevel: 2
---

# 为什么 JDK1.8 对 HashMap 进行了红黑树的改动

## 回答重点

- **核心目的**
  - 解决因哈希冲突过多导致链表过长，进而引起的查询性能下降问题。
- **JDK 1.8 之前**
  - 使用**链表**解决哈希冲突。
  - **缺点**: 当冲突严重时，链表变长，时间复杂度从 O(1) 退化为 O(n)。
- **JDK 1.8 的改进**
  - 当链表长度达到一定阈值时，会转换为**红黑树**。
    - 红黑树是一种自平衡二叉查找树，其查找、插入、删除的时间复杂度稳定在 **O(log n)**，远优于链表的 O(n)。
- **转换规则**
  - **树化**: 链表长度 **≥ 8** 时，转换为红黑树。
  - **反树化**: 红黑树节点数 **≤ 6** 时，退化回链表。

## 扩展知识

### 链表与红黑树的转换时机

- **双重条件**
  - 1. 桶内元素数量 **≥ 8**
  - 2. 并且，HashMap 的数组长度 **≥ 64**
- **特殊情况**
  - 如果桶内元素 ≥ 8，但数组长度 < 64，会优先进行**扩容(resize)**，而不是树化。
- **源码佐证**
  - 1. 判断桶内元素数量是否达到树化阈值（TREEIFY_THRESHOLD = 8）
    - <img src="https://pic.code-nav.cn/mianshiya/question_picture/1783388929455529986/9ksKxXIh_image_mianshiya.png" width="600">
  - 2. `treeifyBin` 方法内部进一步判断数组长度是否足够大
    - <img src="https://pic.code-nav.cn/mianshiya/question_picture/1783388929455529986/neWKcf70_image_mianshiya.png" width="600">

### 为什么数组长度要 ≥ 64 才树化？

- **避免不必要的树化**
  - 在数组容量较小时，哈希冲突的概率相对较高。通过扩容可以有效分散元素、减少冲突。
  - 如果在小容量时就树化，可能刚完成转换，下一次`put`操作就触发了扩容，导致树结构被拆散，造成了不必要的性能开销。
- **减少内存占用**
  - 红黑树的节点（`TreeNode`）所占用的内存比普通链表节点（`Node`）要多。
  - 在数据规模较小时，优先扩容而非树化，是一种空间与时间上的权衡。

### 为什么不直接用红黑树？

- **空间成本**
  - 源码注释明确指出：**红黑树节点的大小约是普通节点的两倍**。
  - <img src="https://pic.code-nav.cn/mianshiya/question_picture/1783397053004488705/20220219202947.png" width="550">
  - 在节点数较少时，链表的性能已经足够好，使用链表更节省内存。
- **为什么树化阈值是 8？**
  - 这是一个基于**泊松分布**的统计学选择。
  - 源码注释提到：在理想情况下（哈希函数均匀分布），单个哈希桶中出现 8 个元素的概率是**千万分之六 (0.00000006)**，是极小概率事件。
  - <img src="https://pic.code-nav.cn/mianshiya/question_picture/1783397053004488705/20220219202956_mianshiya.png" width="500">
  - 选择 8 是在**时间**（避免链表过长）和**空间**（红黑树占用内存）之间的一个理想平衡点。

### 为什么退化阈值是 6？

- **设置缓冲地带**
  - 如果树化和退化的阈值相同（比如都是 8），那么当一个桶内元素在 8 和 9 之间波动时，会频繁地进行树和链表的转换，这会带来额外的性能开销。
  - 采用 8 作为树化阈值和 6 作为退化阈值，中间留出了一个**缓冲空间**，避免了这种“反复横跳”的情况。

### 相关知识点

- [TreeMap 与红黑树的关系](https://www.mianshiya.com/bank/1788408712975282177/question/1780933294796337153)
