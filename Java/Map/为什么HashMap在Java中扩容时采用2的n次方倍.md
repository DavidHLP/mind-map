---
title: 为什么HashMap在Java中扩容时采用2的n次方倍?
---

# HashMap 容量为 2 的 n 次方原因

## 核心原因

- **提高哈希值分布均匀性**
- **提升哈希计算效率**

## 关键实现

- **索引计算公式: `(n - 1) & hash`**
  - 前提条件: 数组容量 `n` 必须是 `2` 的 `n` 次方
  - 优势: 位运算的效率远高于常规的取模运算 (`hash % n`)
- **高效的扩容 (Rehashing)**
  - 迁移判断: 扩容时，通过简单的位运算即可判断元素是否需要迁移及其新位置
  - 性能提升: 减少了重新计算所有元素索引的开销

## 扩展知识

### 哈希分布均匀性

- **原理**
  - 当容量 `n` 为 `2` 的 `n` 次方时, `n - 1` 的二进制表示中低位全为 `1`
  - 与哈希值进行 `&` 运算，可以充分利用哈希值的低位信息，减少冲突
- **正例 (n=64)**
  - `64` -> `0100 0000`
  - `63` -> `0011 1111`
  - `& 63` -> 运算结果能均匀地反应哈希码的随机性
- **反例**
  - 如果 `&` 一个低位不全为 `1` 的数
  - 会导致某些索引位永远无法被计算到，增加哈希冲突

### 位运算 vs. 取模运算

- **常规方法**
  - 通过取模 `%` 运算计算下标: `hash % n`
- **HashMap 的优化**
  - **等价公式**: 当 `b` 是 `2` 的 `n` 次幂时, `a % b` 等价于 `a & (b - 1)`
  - **性能优势**: CPU 处理位运算(`&`)的速度比取模运算(`%`)更快
