---
markmap:
  colorFreezeLevel: 2
---

# Java 中 HashMap 原理

## 基本概念

- 基于哈希表的数据结构
- 存储 **键值对 (key-value)**
- 核心思想：通过键的哈希值映射到数组索引位置

## 底层结构

- JDK 1.7 及之前：数组 + 链表
- JDK 1.8 及之后：数组 + 链表 / 红黑树（当链表过长时转换为红黑树）

## 哈希计算

- 使用 `key.hashCode()` 计算哈希值
- 通过 `(n - 1) & hash` 计算索引位置
- 哈希值经过扰动处理 → 减少哈希冲突

## 哈希冲突处理

- 同一索引位置存放多个元素时
  - 链表存储（拉链法）
  - 链表过长时转为红黑树（提高查询效率）

### 红黑树优化（JDK 1.8+）

- 当桶中链表长度 **超过 8** 时 → 转换为红黑树
  - 将最坏查找复杂度从 **O(n) 降低到 O(log n)**
- 当树中元素数量 **低于 6** 时 → 转回链表
  - 避免不必要的树操作开销

## hashCode() 与 equals() 的重要性

- HashMap 键必须实现 `hashCode()` 和 `equals()`
- `hashCode()`：决定键的存储位置
- `equals()`：判断键是否相同
- put 操作时：
  - 若两个键 hashCode 相同但 equals 返回 false → 视为不同键，存储在同一个桶的不同位置
- 误用 `hashCode()` 和 `equals()` → 导致元素无法正常查找或插入

## 扩容机制

- 默认初始容量：16
- 默认负载因子：0.75
- 扩容阈值：容量 × 负载因子
  - 例如：16 × 0.75 = 12
- 超过阈值时触发扩容
  - 容量翻倍
  - 重新分配元素位置（rehash）
  - 扩容开销较大，频繁扩容影响性能

### 容量与负载因子的选择

- 默认组合：**16 容量 + 0.75 负载因子** → 性能与空间的平衡
- 较高负载因子（如 1.0）
  - 节省空间
  - 但冲突概率增加
- 较低负载因子
  - 冲突减少
  - 但空间浪费增加
- 建议：若已知容量需求 → **提前设定合适初始容量**，减少扩容开销
