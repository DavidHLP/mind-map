# MySQL 中的数据排序

## 1. 索引排序（Index Sort）

### 条件

- ORDER BY 子句包含的字段已经在索引中
- 索引顺序与 ORDER BY 子句顺序一致

### 排序过程

- MySQL 直接利用索引完成排序，无需额外排序操作
- 查询效率高，避免使用内存或磁盘排序

## 2. 内存排序（In-Memory Sort）

### 条件

- ORDER BY 字段未完全命中索引
- 数据量较小，可在内存中排序

### 排序方式

#### 2.1 单路排序（Single-Pass Sort）

- select 列数据长度 ≤ `max_length_for_sort_data`（默认 4096 字节）
- 排序字段和查询字段都放入 `sort_buffer`
- 排序完成后直接得到结果集，无需回表
- 效率高，减少回表操作

#### 2.2 双路排序（Two-Pass Sort）

- select 列数据长度 > `max_length_for_sort_data`
- `sort_buffer` 中只放置主键或 row_id + 排序字段
- 排序后，再通过回表查询完整数据
- 排序过程需要两次查询，效率较低
- 示例：

```sql
SELECT a, b, c
FROM table1
WHERE a = 'xxxx'
ORDER BY b;
```

- 如果 select 列数据过长 → 双路排序
- sort_buffer 仅存 id + b
- 排序完成后回表取 a, b, c

## 3. 文件排序（Filesort）

### 条件

- 查询字段未命中索引
- 数据量大，内存无法容纳排序

### 排序过程

- 使用磁盘文件进行外部排序
- 常用归并排序：

  1. 数据分块写入临时文件
  2. 单独对每个文件排序
  3. 合并排序后的文件形成最终有序结果

- 调整 `sort_buffer_size` 可以尽量减少磁盘排序，提高效率

### 排查方法

- 使用 `EXPLAIN` 分析 SQL
- 如果 `Extra` 列显示 `Using filesort` → 使用了文件排序

## 4. 总结排序类型

| 排序类型     | 条件                      | 排序位置 | 回表     | 适用场景               |
| ------------ | ------------------------- | -------- | -------- | ---------------------- |
| 索引排序     | ORDER BY 字段完全命中索引 | 索引     | 无       | 查询字段全部在索引中   |
| 内存排序单路 | select 列数据较短         | 内存     | 无       | 数据量小，字段短       |
| 内存排序双路 | select 列数据较长         | 内存     | 需要回表 | 数据量小，但字段长     |
| 文件排序     | 数据量大，索引未命中      | 磁盘     | 需要回表 | 数据量大，无法内存排序 |

## 面试速记

- **Q1: 索引排序条件？**

  - ORDER BY 字段全命中索引，顺序一致

- **Q2: 单路排序 vs 双路排序？**

  - 单路：字段短，全放内存，效率高
  - 双路：字段长，内存只放 id + 排序字段，需要回表

- **Q3: 文件排序（filesort）使用场景？**

  - 索引未命中，数据量大，超出 sort_buffer

- **Q4: 文件排序原理？**

  - 外部归并排序：分块排序 → 合并排序

- **Q5: 优化排序效率方法？**

  - 尽量使用索引排序
  - 调大 `sort_buffer_size`，减少文件排序
  - 使用覆盖索引，减少回表
